#ifndef RP_CMA_SMALL_H
#define RP_CMA_SMALL_H

#include <cmaes.h>
#include "hyperparameters.h"
#include <random>
//#include <limits>

namespace libcmaes {

FitFunc fnull = [](const double *x, const int N) {return 0;};

template <class TBigStrat,class TCovarianceUpdate,class TGenoPheno=GenoPheno<NoBoundStrategy>>
class RPCMASmall : public CMAStrategy<TCovarianceUpdate,TGenoPheno>
{
protected:

	TBigStrat* _bdimstrat;

	dMat _randProjection;

    /**
     * \brief Setup parameters for small dimension strategy
     * @param parameters forwarded by big dimension strategy
     */
	CMAParameters<TGenoPheno>& setupParameters(CMAParameters<TGenoPheno>& params) const {
		params.set_uh(false);
		params.set_elitism(0);
		params.set_str_algo("cmaes");
		params.initialize_parameters();
		return params;
	}

public:

      /**
       * \brief dummy constructor
       */

      /**
       * \brief constructor. We assume bdimstrat to be fully setup in way to use its properties
       * @param func objective function to minimize
       * @param parameters stochastic search parameters
       */
      RPCMASmall(CMAParameters<TGenoPheno> sparams, TBigStrat* bdimstrat) : 
		CMAStrategy<TCovarianceUpdate,TGenoPheno>(fnull, setupParameters(sparams)),
		_bdimstrat(bdimstrat),
		_randProjection(grp(sparams.dim(), bdimstrat->get_parameters().dim())) {
		//is licit since others values depending of x0 evoluates as x0 does (no one at wrtiting moment)
		CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters.set_x0(_randProjection * bdimstrat->get_parameters().get_x0min(), _randProjection * bdimstrat->get_parameters().get_x0max());
	  }

      /**
       * \brief constructor for starting from an existing solution.
       * @param func objective function to minimize
       * @param parameters stochastic search parameters
       * @param cmasols solution object to start from
       */

	~RPCMASmall() {}

    /**
     * \brief Build the fvalue copying it from TBigStrat candidate
	 * @param the column of the candidate to be evaluated
	 * @param the candidates stored as column of the matrix
	 * @return the computed function value
     */
/*
	virtual inline double build_fvalue(const int &col, const dMat& candidates)
      {
      return _bdimstrat->get_solutions()._candidates.at(col).get_fvalue();
      }
*/

      /**
       * \brief Generate a Random Projection from big to small space
       * @param d is the small dimension
	   * @param D is the big dimension
       */
	static dMat grp(int d, int D) {
		dMat result(d,D);

		std::random_device rd;
		//std::normal_distribution<double> norm(0.0,1.0);
		std::uniform_real_distribution<double> uni_c(0.0,1.0);//continuous
		std::uniform_int_distribution<int> uni_d(0,1);//discrete
		std::mt19937 gen(rd());

		Eigen::RowVectorXd randVector(D);
		Eigen::RowVectorXd newBasisCandidate(D);

		for(int i=0; i< d; i++) {
			for (int j=0; j< D; j++) {
				if(uni_c(gen) < HyperParameters::spc()) {
					newBasisCandidate(j) = randVector(j) = 0;
				} else {
					newBasisCandidate(j) = randVector(j) = 2*uni_d(gen)-1;
				}

//				newBasisCandidate(j) = randVector(j) = norm(gen);
			}

			for(int j=0; j< i; j++) {
				newBasisCandidate -= result.row(j) * randVector.dot(result.row(j));//we don't need to divide by result.row(j).norm() cause all vectors are normalized
			}

			if(newBasisCandidate.norm() > HyperParameters::eps) {
				result.row(i) = newBasisCandidate / newBasisCandidate.norm();
			} else {
				i--;
			}
		}
		return result;
	}

	inline dMat randProjection() {
		return _randProjection;
	}

	void re_grp() {
		_randProjection = grp(CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters.dim(), _bdimstrat->get_parameters().dim());
	}

      /**
       * \brief Compute a value proportionnal to the probability of X projection, according to the small gaussian distribution
       * @param X the point to evaluate. Note X belongs to big space.
       */
	inline double probabilityFitness(dVec X) {
		return (CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.csqinv() * (_randProjection * X - CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.xmean())).squaredNorm();
	}

      /**
       * \brief Select the best candidate from the set given in parameters
       * @param The set of candidates generated by TBigStrat (candidates are the matrix columns).
       */
	dVec bestCandidate(dMat candidates) {
		if(candidates.rows() < 1) {//should not occur in normal process
			//TODO: throw exception or compute error
			return dVec();//empty vector
		}
		dVec max(candidates.rows());
		double maxValue = probabilityFitness(candidates.col(0));

		double candidateMark;

		for(int i=1; i< candidates.cols(); i++) {
			candidateMark = probabilityFitness(candidates.col(i));
			if(candidateMark > maxValue) {
				max = candidates.col(i);
				maxValue = candidateMark;
			}
		}

		return max;
	}

      /**
       * \brief Actually just make a call to initialize_esolver_and_solutions
       * @return Empty matrix
       */
	virtual dMat ask() {
		CMAStrategy<TCovarianceUpdate,TGenoPheno>::initialize_esolver_and_solutions();
		return dMat();
	}

	virtual void eval(const dMat &candidates=dMat(),const dMat &phenocandidates=dMat())
	{
#ifdef HAVE_DEBUG
		std::chrono::time_point<std::chrono::system_clock> tstart = std::chrono::system_clock::now();
#endif
		// one candidate per row.
		for (int r=0;r<_bdimstrat->get_solutions().size();r++)
		{
			Candidate& candidate_r = _bdimstrat->get_solutions()._candidates.at(r);
			CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions._candidates.at(r).set_x(_randProjection * candidate_r.get_x_dvec());
			CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions._candidates.at(r).set_id(candidate_r.get_id());
			CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions._candidates.at(r).set_fvalue(candidate_r.get_fvalue());
		}

		CMAStrategy<TCovarianceUpdate,TGenoPheno>::update_fevals(candidates.cols());

#ifdef HAVE_DEBUG
		std::chrono::time_point<std::chrono::system_clock> tstop = std::chrono::system_clock::now();
		_solutions._elapsed_eval = std::chrono::duration_cast<std::chrono::milliseconds>(tstop-tstart).count();
#endif
	}

	virtual void tell()
	{
#ifdef HAVE_DEBUG
		std::chrono::time_point<std::chrono::system_clock> tstart = std::chrono::system_clock::now();
#endif
		// call on tpa computation of s(t)
		if (CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters._tpa == 2 && CMAStrategy<TCovarianceUpdate,TGenoPheno>::_niter > 0)
			CMAStrategy<TCovarianceUpdate,TGenoPheno>::tpa_update();

		// update function value history, as needed.
		CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.update_best_candidates();

		// CMA-ES update, depends on the selected 'flavor'.
		TCovarianceUpdate::update(CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters,CMAStrategy<TCovarianceUpdate,TGenoPheno>::_esolver,CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions);

		if (CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters._uh)
			if (CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions._suh > 0.0)
				CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions._sigma *= CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters._alphathuh;

		// other stuff.
		if (!CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters._sep && !CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters._vd)
			CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.update_eigenv(CMAStrategy<TCovarianceUpdate,TGenoPheno>::_esolver._eigenSolver.eigenvalues(), CMAStrategy<TCovarianceUpdate,TGenoPheno>::_esolver._eigenSolver.eigenvectors());
		else CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.update_eigenv(CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions._sepcov,
			dMat::Constant(CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters._dim,1,1.0));
#ifdef HAVE_DEBUG
		std::chrono::time_point<std::chrono::system_clock> tstop = std::chrono::system_clock::now();
		CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions._elapsed_tell = std::chrono::duration_cast<std::chrono::milliseconds>(tstop-tstart).count();
#endif
	}
};

}

#endif

