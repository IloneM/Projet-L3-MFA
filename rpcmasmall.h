#ifndef RP_CMA_SMALL_H
#define RP_CMA_SMALL_H

#include <cmaes.h>
#include "hyperparameters.h"
#include <random>
//#include <limits>

namespace libcmaes {

FitFunc fnull = [](const double *x, const int N) {return 0;};

template <class TCovarianceUpdate,class TGenoPheno=GenoPheno<NoBoundStrategy>> class RPCMABig;

template <class TCovarianceUpdate,class TGenoPheno=GenoPheno<NoBoundStrategy>>
class RPCMASmall : public CMAStrategy<TCovarianceUpdate,TGenoPheno>
{
      //template <class U, class V> friend class RPCMABig;
protected:

	RPCMABig<TCovarianceUpdate,TGenoPheno>* _bdimstrat;

	dMat _randProjection;

    /**
     * \brief Setup parameters for small dimension strategy
     * @param parameters forwarded by big dimension strategy
     */
	CMAParameters<TGenoPheno>& setupParameters(CMAParameters<TGenoPheno>& params) const {
		params.set_uh(false);
		params.set_str_algo("cmaes");
		params.initialize_parameters();
		return params;
	}

public:

      /**
       * \brief dummy constructor
       */

      /**
       * \brief constructor. We assume bdimstrat to be fully setup in way to use its properties
       * @param func objective function to minimize
       * @param parameters stochastic search parameters
       */
      RPCMASmall(CMAParameters<TGenoPheno> sparams, RPCMABig<TCovarianceUpdate,TGenoPheno>* bdimstrat) : 
		CMAStrategy<TCovarianceUpdate,TGenoPheno>(fnull, setupParameters(sparams)),
		_bdimstrat(bdimstrat),
		_randProjection(grp(sparams.dim(), bdimstrat->get_parameters().dim())) {
		//is licit since others values depending of x0 evoluates as x0 does (no one at wrtiting moment)
		CMAStrategy<TCovarianceUpdate,TGenoPheno>::_parameters.set_x0(_randProjection * bdimstrat->get_parameters().get_x0min(), _randProjection * bdimstrat->get_parameters().get_x0max());
	  }

      /**
       * \brief constructor for starting from an existing solution.
       * @param func objective function to minimize
       * @param parameters stochastic search parameters
       * @param cmasols solution object to start from
       */

	~RPCMASmall() {}

    /**
     * \brief Build the fvalue copying it from RPCMABig candidate
	 * @param the column of the candidate to be evaluated
	 * @param the candidates stored as column of the matrix
	 * @return the computed function value
     */
	virtual inline double build_fvalue(const int &col, const dMat& candidates)
      {
      return _bdimstrat->get_solutions()._candidates.at(col).get_fvalue();
      }

      /**
       * \brief Generate a Random Projection from big to small space
       * @param d is the small dimension
	   * @param D is the big dimension
       */
	static dMat grp(int d, int D) {
		dMat result(d,D);

		std::random_device rd;
		std::normal_distribution<double> norm(0.0,1.0);
		std::mt19937 gen(rd());

		Eigen::RowVectorXd randVector(D);
		Eigen::RowVectorXd newBasisCandidate(D);

		for(int i=0; i< d; i++) {
			for (int j=0; j< D; j++) {
				newBasisCandidate(j) = randVector(j) = norm(gen);
			}

			for(int j=0; j< i; j++) {
				newBasisCandidate -= result.row(j) * randVector.dot(result.row(j));//we don't need to divide by result.row(j).norm() cause all vectors are normalized
			}

			if(newBasisCandidate.norm() > HyperParameters::eps) {
				result.row(i) = newBasisCandidate / newBasisCandidate.norm();
			} else {
				i--;
			}
		}
		return result;
	}

	inline dMat randProjection() {
		return _randProjection;
	}

      /**
       * \brief Compute a value proportionnal to the probability of X projection, according to the small gaussian distribution
       * @param X the point to evaluate. Note X belongs to big space.
       */
	inline double probabilityFitness(dVec X) {
		return (CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.csqinv() * (_randProjection * X - CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.xmean())).squaredNorm();
	}

      /**
       * \brief Select the best candidate from the set given in parameters
       * @param The set of candidates generated by RPCMABig (candidates are the matrix columns).
       */
	dVec bestCandidate(dMat candidates) {
		if(candidates.rows() < 1) {//should not occur in normal process
			//TODO: throw exception or compute error
			return dVec();//empty vector
		}
		dVec max(candidates.rows());
		double maxValue = probabilityFitness(candidates.col(0));

		double candidateMark;

		for(int i=1; i< candidates.cols(); i++) {
			candidateMark = probabilityFitness(candidates.col(i));
			if(candidateMark > maxValue) {
				max = candidates.col(i);
				maxValue = candidateMark;
			}
		}

		return max;
	}

      /**
       * \brief Actually just make a call to initialize_esolver_and_solutions
       * @return Empty matrix
       */
	virtual dMat ask() {
		CMAStrategy<TCovarianceUpdate,TGenoPheno>::initialize_esolver_and_solutions();
		return dMat();
	}
};

}

#endif

