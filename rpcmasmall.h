#ifndef RP_CMA_SMALL_H
#define RP_CMA_SMALL_H

//#include "abstractrpcma.h"
#include <cmaes.h>
#include "hyperparameters.h"

/*
 * Importants points procedures seems to be eval for N_D and ask for n_d.
 * A overall class must be implemented
 */

using namespace libcmaes;

FitFunc fnull = [](const double *x, const int N) {return 0;};

template <class TCovarianceUpdate,class TGenoPheno=GenoPheno<NoBoundStrategy>> class RPCMABig;

template <class TCovarianceUpdate,class TGenoPheno=GenoPheno<NoBoundStrategy>>
class RPCMASmall : public CMAStrategy<TCovarianceUpdate,TGenoPheno>//AbstractRPCMA<TCovarianceUpdate,TGenoPheno>
{
protected:

	RPCMABig<TCovarianceUpdate,TGenoPheno>* _bdimstrat;

	dMat _randProjection;

//	dMat _covarianceInverse;

public:

      /**
       * \brief Generate a Random Projection from big to small space
       * @param d is the small dimension
	   * @param D is the big dimension
	   * TODO: try to make random as in enmvn.h
       */
	static dMat grp(int d, int D) {
		dMat result(d,D);

		for(int i=0; i< d; i++) {
			Eigen::RowVectorXd randVector = Eigen::RowVectorXd::Random(D);

			Eigen::RowVectorXd newBasisCandidate = randVector;

			for(int j=0; j< i; j++) {
				newBasisCandidate -= result.row(j) * randVector.dot(result.row(j));//we don't need to divide by result.row(j).norm() cause all vectors are normalized
			}

			if(newBasisCandidate.norm() > HyperParameters::eps) {
				result.row(i) = newBasisCandidate / newBasisCandidate.norm();
			} else {
				i--;
			}
		}
		return result;
	}

	inline dMat randProjection() {
		return _randProjection;
	}

      /**
       * \brief Compute a value proportionnal to the probability of X projection, according to the small gaussian distribution
       * @param X the point to evaluate. Note X belongs to big space.
       */
	inline double probabilityFitness(dVec X) {
		dMat halfValue = CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.csqinv() * (_randProjection * X - CMAStrategy<TCovarianceUpdate,TGenoPheno>::_solutions.xmean());
		return halfValue.transpose() * halfValue;
	}
/*
	void setCovarianceInverse(dMat newMatrix) {
		_covarianceUpdate = newMatrix;
	}
*/
      /**
       * \brief Select the best candidate from the set given in parameters
       * @param The set of candidates generated by RPCMABig (candidates are the matrix columns).
       */
	dVec bestCandidate(dMat candidates) {
		if(candidates.rows() < 1) {//should not occur in normal process
			//throw exception or compute error
			return dVec();//empty vector
		}
		dVec max(candidates.rows());
		double maxValue = probabilityFitness(candidates.col(0));

		double candidateMark;

		for(int i=1; i< candidates.cols(); i++) {
			candidateMark = probabilityFitness(candidates.col(i));
			if(candidateMark > maxValue) {
				max = candidates.col(i);
				maxValue = candidateMark;
			}
		}

		return max;
	}
      /**
       * \brief dummy constructor
       */
      RPCMASmall(RPCMABig<TCovarianceUpdate,TGenoPheno>* bdimstrat,
					  dMat randProjection) : CMAStrategy<TCovarianceUpdate,TGenoPheno>(), _bdimstrat(bdimstrat), _randProjection(randProjection) {}
    
      /**
       * \brief constructor. We assume bdimstrat to be fully setup in way to use its properties
       * @param func objective function to minimize
       * @param parameters stochastic search parameters
       */
      RPCMASmall(const int d, RPCMABig<TCovarianceUpdate,TGenoPheno>* bdimstrat) : _bdimstrat(bdimstrat),
		_randProjection(grp(d, bdimstrat->get_parameters().dim())) {

		//std::vector<double> fake_x0(SMALL_DIM,0);
		//CMAParameters<TGenoPheno> sparams(fake_x0, params.get_sigma_init(), params.lambda(), params.get_seed(), params.get_gp());
		//sparams.set_x0(_randProjection * params.get_x0min(), _randProjection * params.get_x0max());//set the true x0
		CMAParameters<TGenoPheno> sparams(d, new double[d], bdimstrat->get_parameters().get_sigma_init());
//		sparams.set_dim(d);
		sparams.set_x0(_randProjection * sparams.get_x0min(), _randProjection * sparams.get_x0max());
		/*
		 * As x0 isn't changed by initialize_parameters, we don't call the procedure. Must evoluate as library does
		 */
//		sparams.initialize_parameters();

/*
		_candidates = CMAStrategy<TCovarianceUpdate,TGenoPheno>::ask();
		std::cout << _sdimstrat->ask();
*/		
		CMAStrategy<TCovarianceUpdate,TGenoPheno>(fnull, sparams);

	  }

      /**
       * \brief constructor for starting from an existing solution.
       * @param func objective function to minimize
       * @param parameters stochastic search parameters
       * @param cmasols solution object to start from
       */
      RPCMASmall(RPCMABig<TCovarianceUpdate,TGenoPheno>* bdimstrat,
		  dMat randProjection,
		  FitFunc &func,
		  CMAParameters<TGenoPheno> &parameters,
		  const CMASolutions &cmasols) : CMAStrategy<TCovarianceUpdate,TGenoPheno>(func, parameters, cmasols), _bdimstrat(bdimstrat), _randProjection(randProjection) {}

	dMat ask() {
		return _randProjection *  _bdimstrat->candidates();
	}

/*    
	  ~RPCMASmall() {
	  }
*/
};

#endif

